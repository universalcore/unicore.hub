from sqlalchemy import Column, Integer, Unicode, event
from sqlalchemy_utils import PasswordType, JSONType
from sqlalchemy.orm import Session
from sqlalchemy.ext.mutable import MutableDict

from unicore.hub.service import Base
from unicore.hub.service.utils import make_slugs


class ModelException(object):
    pass


class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    username = Column(Unicode(255), unique=True)
    password = Column(PasswordType(schemes=['pbkdf2_sha256']))
    app_data = Column(MutableDict.as_mutable(JSONType))

    @classmethod
    def authenticate(cls, username, password, request):
        user = request.db.query(cls) \
            .filter(cls.username == username) \
            .first()

        if user is not None and user.password == password:
            return (user.id, )

        return None


class App(Base):
    __tablename__ = 'apps'
    id = Column(Integer, primary_key=True)
    title = Column(Unicode(255), nullable=False)
    slug = Column(Unicode(255), unique=True, nullable=False)
    password = Column(PasswordType(schemes=['pbkdf2_sha256']), nullable=False)

    @classmethod
    def authenticate(cls, app_id, password, request):
        app = request.db.query(cls).get(app_id)

        if app is not None and app.password == password:
            return (app_id, )

        return None

    def set_unique_slug(self, session):
        if self.title is None:
            raise ModelException(
                "%r 'title' field is required" % self.__class__)

        # NOTE: race condition, but I'm leaving it to the
        # database to raise an exception
        for slug in make_slugs(self.title):
            q = session.query(self.__class__) \
                       .filter(self.__class__.slug == slug) \
                       .exists()
            if session.query(q).scalar():
                continue
            self.slug = slug
            break


@event.listens_for(Session, 'before_commit')
def set_derived_fields(session):
    """ Sets derived, autogenerated fields like slug once-off
    """
    with session.no_autoflush:  # don't flush until slug is set
        for obj in session.new:
            if isinstance(obj, App):
                obj.set_unique_slug(session)
